## 二叉树
- 最大堆：根节点值最大
- 最小堆：根节点值最小
- 二叉搜索树（二叉查找树）：BST，Binary Sort Tree
    - 左子节点总是小于或等于根节点，右子节点总是大于或等于根节点
    - 查找、插入、删除时间复杂度为O(logN)。极端情况，变成一种线性链表结构，时间复杂度变为O(N)
- 平衡二叉树：AVL树，一种自平衡树
    - 左节点小于根节点，右节点大于根节点，左子树和右子树高度差不得超过1（保证不会蜕变为链表）
    - 查找、插入、删除时间复杂度为O(logN)，维持自身平衡，插入和删除节点操作，需要对接点进行频繁旋转
## 树
- 平衡树：B树，Blance-Tree，多路平衡树。
    - 一个m阶的B树规定了：
        - 1.根结点至少有两个子女。
        - 2.每个中间节点都包含k-1个元素和k个孩子，其中 m/2 <= k <= m 。
        - 3.每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m。
        - 4.所有的叶子结点都位于同一层。
        - 5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。
    - B树每一层存放了更多的节点，由AVL树的瘦高变成了矮胖
- B+树：B+树每个非叶子节点存放的元素只用于索引作用，所有数据存放在叶子节点
    - 一个m阶的B+树规定了：
        - 1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。
        - 2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
        - 3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。
    - 非叶子结点中存放的元素不存放数据，所以每一层可以容纳更多元素，也就是磁盘中的每一页可以存放更多元素。这样在查找时，磁盘IO的次数也会减少
- 红黑树：RB-Tree，把树中的节点定义为红、黑两种颜色，通过规则确保从根节点到叶节点的最长路径的长度不超过 最短路径的两倍。
    - 红黑树规定： 
        - 1.节点是红色或黑色。
        - 2.根节点是黑色。
        - 3.每个叶子节点都是黑色的空节点（NIL节点）。
        - 4.每个红色节点的两个子节点都是黑色。也就是说从每个叶子到根的所有路径上不能有两个连续的红色节点)。
        - 5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。
    - 红黑树能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作
## 二叉树遍历

- 前序遍历：根节点，左子节点，右子节点
- 中序遍历：左子节点，根节点，右子节点
- 后序遍历：左子节点，右子节点，根节点

3种遍历都有递归和循环两种不同实现方式，每种遍历的递归实现都比循环实现简洁很多。

- 宽度优先遍历：先访问树的第一层节点，再访问树的第二层节点，同一层节点中，从左到右的顺序依次访问

## 重建二叉树

### 题目：

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含
重复的数字。前序遍历 preorder = [3,9,20,15,7]，中序遍历 inorder = [9,3,15,20,7]

### 解法：

前序遍历第一个值是根节点， 在中序遍历中，根节点在序列中间，左子树节点的值在根节点左侧，右子树节点的值在根节点右侧。 在前序遍历中，同样可以确定左子树节点和右子树节点的值。
分别找到了左、右子树的前序遍历序列和中序遍历序列，可以采用递归的方法去分别构建左、右子树

### 复杂度分析：